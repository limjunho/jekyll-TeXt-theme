---
title: Baekjoon 1011번
tags: Algorithm
---

[send me email](mailto:jewel7492@gmail.com) if you have any questions.

<!--more-->

---
### Problem  
   
![그림1](/assets/Baekjoon/1011/1.PNG)  


### Solution

|distance|warp|max spped|result|
|:--------:|:----:|:---------:|:------:|
|1|1|1|1|
|4|3|2|121|
|9|5|3|12321|
|16|7|4|1234321|
|25|9|5|123454321|
|N^2|2*N-1|square(N)|12345...N....54321|

> **distance가 18인 경우**

**1. distance를 넘지 않는 N을 구한다.**
    * N = 4
**2. distance - N*N**
    * 18 - 16 = 2
**3. distance가 16인 경우 7번의 워프를 진행한다. 따라서 2광년을 이동하기 위한 이동 횟수를 더해주면 최종 워프 횟수이다.**  
    * 남은 거리 / N 을 올림수 처리하여 구한다.

### Code  
```cpp
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    int T, x, y;
    int result, distance;

    cin >> T;

    for (int i = 0; i < T; i++)
    {
        cin >> x >> y;
        distance = y - x;

        long long j = 1;
        while (j * j <= distance)
        {
            j++;
        }
        j--;

        result = distance - (j * j);
        // ceil은 파라미터를 올림 처리하여 리턴하는 함수
        result = ceil((double)result / (double)j);

        printf("%d\n", j * 2 - 1 + result);
    }

    return 0;
}
```