---
title: React.memo Example(Hook)
tags: React
---

**React.memo로 컴포넌트의 리렌더링을 방지하는 예제**  
**React.memo??**  
컴포넌트에서 리렌더링이 필요한 상황에서만 리렌더링을 하도록 하는 함수  

[React Array Example코드](https://github.com/limjunho/React/tree/master/array_ex)  
예제 소스코드(github)

**React 성능 최적화**  
[useMemo Example](https://limjunho.github.io/2020/09/21/useMemo.html)는 특정 결과값을 재사용  
[useCallback Example](https://limjunho.github.io/2020/09/21/useCallback.html) 특정 함수를 재사용  

[send me email](mailto:jewel7492@gmail.com) if you have any questions.  

<!--more-->

---

### React.memo   

사용법은 React.memo()로 감싸주면 된다.  

```jsx
import React from 'react';

function CreateUser({ username, phonenumber, onChange, onCreate }) {
  return (
    <div>
      <input
        name="username"
        placeholder="input name..."
        onChange={onChange}
        value={username}
      />
      <br />
      <input
        name="phonenumber"
        placeholder="input phonenumber..."
        onChange={onChange}
        value={phonenumber}
      />
      <br />
      <button onClick={onCreate}>submit!!</button>
    </div>
  );
}

export default React.memo(CreateUser);
```
**CreateUser.js**  
<br />
<br />

```jsx
import React, {useEffect} from 'react';

const User = React.memo(function User({ user, onRemove, onUpdate }) {
    useEffect(() => {
        console.log("컴포넌트 등장!");
        console.log(user);
        return () =>{
            console.log("컴포넌트 퇴장..");
            console.log(user);
        }
    }, []);
    return (
        <div>
            <b>{user.username}</b> <span>({user.phonenumber})</span>
            <button onClick={() => onRemove(user.id)}>삭제</button>
            <button onClick={() => onUpdate(user.id)}>수정</button>
        </div>
    )
});

function UserList({ users, onRemove, onUpdate }) {
    return (
        <div>
            {users.map(user => (
                <User user={user} 
                key={user.id} 
                onRemove={onRemove} 
                onUpdate={onUpdate} />
            ))}
        </div>
    );
}

export default React.memo(UserList);
```
**UserList.js**  
<br />
<br />

**이렇게 수정하면 input을 수정할 때 UserList는 리렌더링 되지 않게 최적화 할 수 있다.**  
하지만 하나라도 User를 추가하거나 제거, 수정등의 작업을 하면 UserList와 CreateUser도 리렌더링된다.  
<br />

**Why?**  
```jsx
const onCreate = useCallback(() => {
    const user = {
      id: nextId.current,
      username,
      phonenumber
    };
    setUsers(users.concat(user))

    setInputs({
      username: '',
      phonenumber: ''
    });

    nextId.current += 1;
  }, [users, username, phonenumber]);

  const onRemove = useCallback(
    id => {
      setUsers(users.filter(user => user.id !== id));
    },
    [users]
  );
```
users의 배열이 바뀔 때 마다 on...함수들이 새로 만들어지기 때문이다.  
**useCallback의 deps에 users가 있기 때문**  
이해가 안간다면 [useCallback](https://limjunho.github.io/2020/09/21/useCallback.html)참조  

### 함수형 업데이트를 통한 최적화    

